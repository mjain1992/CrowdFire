import twitter4j.*;
import twitter4j.auth.AccessToken;
import twitter4j.auth.OAuth2Token;
import twitter4j.conf.ConfigurationBuilder;

import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.*;

class TwitterFollowers{
	public static String[] fetchBestTimeToPost(Long userId, String userName){
		try{
	        String consumerKey = "kQAbbMEaZKl4LmvvhQNkHeydC";	 
	        String consumerSecret = "2ldZ5fLtPwZgafl8uO6tn4cL0z8dyl1C7tspgjqJU3WfaOY2vl";
	        String accessToken = "965568631-aiUqvxdJWo4c4BBFvMroq2r1QIG17LRFO3IDv58j";
	        String accessTokenSecret = "WkL9t4zLTswsv2xZYsm4NV5rcOM7mNfMOP4Yxmamugj2A";
	        
	        ConfigurationBuilder builder = new ConfigurationBuilder();
	    	builder.setApplicationOnlyAuthEnabled(true);
	        builder.setOAuthConsumerKey(consumerKey);
	        builder.setOAuthConsumerSecret(consumerSecret);
	    	builder.setOAuthAccessToken(accessToken);
	    	builder.setOAuthAccessTokenSecret(accessTokenSecret);
	    	
	    	Twitter twitter = new TwitterFactory(builder.build()).getInstance();
			long cursor =-1L;
		    List<Long> followers = new ArrayList<Long>();
		    boolean userIdFlag = false; 
		    if(userId != null){
		    	userIdFlag = true;
		    }
		    PagableResponseList<User> followersList;
		    do {
		    	if(userIdFlag){
		    		followersList = twitter.getFollowersList(userId, cursor);
		    	}else{
		    		followersList = twitter.getFollowersList(userName, cursor);
		    	}
		    	for (int i = 0; i < followersList.size(); i++)
		        {
		            User user = followersList.get(i);
		            followers.add(user.getId());
		        }
		    } while((cursor = followersList.getNextCursor())!=0 );
		    
		    Paging paging = new Paging();
		    paging.setCount(1);
		    List<Status> statuses = new ArrayList<Status>();
		    
	    	if(userIdFlag){
	    		statuses = twitter.getUserTimeline(userId, paging);
	    	}else{
	    		statuses = twitter.getUserTimeline(userName, paging);
	    	}

		    List<Date> dates = new ArrayList<Date>();
		    if(statuses.size() != 0){
		    	dates.add(statuses.get(0).getCreatedAt());
		    }
		    for(long follower: followers){
		    	List<Status> followerStatus = twitter.getUserTimeline(follower, paging);
		    	if(followerStatus.size() != 0){
			    	dates.add(followerStatus.get(0).getCreatedAt());
			    }
		    }
		    return getBestTime(dates);
		} catch(TwitterException e){
			System.out.println("error occured" + e);
		}
		return new String[]{"Any day", "Any time"};
	}
	
	private static String[] getBestTime(List<Date> createdTimes){
		String[] bestTimes = new String[2];
		int day = 0;
		int time = 0;
		int totalPosts = createdTimes.size();
		DecimalFormat formatter = new DecimalFormat("00");
		Calendar cal = Calendar.getInstance();
		
		for(Date createdTime:createdTimes){
			cal.setTime(createdTime);
			day = day + cal.get(Calendar.DAY_OF_WEEK);
			int minute = cal.get(Calendar.MINUTE);
			String minuteToTwoDigits = formatter.format(minute);
			String formatedTime = String.valueOf(cal.get(Calendar.HOUR_OF_DAY)) + minuteToTwoDigits;
			time = time + Integer.valueOf(formatedTime);
		}
		
		int bestDay = (int) Math.round((double)day/(double)totalPosts);
		bestTimes[0] = getBestDayStr(bestDay);
		int bestTime = (int) Math.round((double)time/(double)totalPosts);
		bestTimes[1] = getBestTimeStr(bestTime);
		return bestTimes;
	}
	
	private static String getBestDayStr(int bestDay){
		switch(bestDay){
		case 1:
			return "Sunday";
		case 2:
			return "Monday";
		case 3:
			return "Tuesday";
		case 4:
			return "Wednesday";
		case 5:
			return "Thursday";
		case 6:
			return "Friday";
		case 7:
			return "Saturday";
		default:
			return "Any day";
		}
	}
	
	private static String getBestTimeStr(int bestTime){
		if(bestTime == 0){
			return "Any time";
		}else{
			try{
				final SimpleDateFormat sdf = new SimpleDateFormat("hhmm");
				final Date dateObj = sdf.parse(String.valueOf(bestTime));
				return new SimpleDateFormat("hh:mm a").format(dateObj);
			}catch(Exception e){
				return "Any time";
			} 
		}
	}
	public static void main(String[] args){
		try{
	        String consumerKey = "kQAbbMEaZKl4LmvvhQNkHeydC";	 
	        String consumerSecret = "2ldZ5fLtPwZgafl8uO6tn4cL0z8dyl1C7tspgjqJU3WfaOY2vl";
	        String accessToken = "965568631-aiUqvxdJWo4c4BBFvMroq2r1QIG17LRFO3IDv58j";
	        String accessTokenSecret = "WkL9t4zLTswsv2xZYsm4NV5rcOM7mNfMOP4Yxmamugj2A";
	        
			ConfigurationBuilder builder = new ConfigurationBuilder();
	//        builder.setUseSSL(true);
	        builder.setApplicationOnlyAuthEnabled(true);
	        builder.setOAuthConsumerKey(consumerKey);
	        builder.setOAuthConsumerSecret(consumerSecret);
	
	        OAuth2Token token = new TwitterFactory(builder.build()).getInstance().getOAuth2Token();
	
	        builder = new ConfigurationBuilder();
	//        builder.setUseSSL(true);
	        builder.setApplicationOnlyAuthEnabled(true);
	        builder.setOAuthConsumerKey(consumerKey);
	        builder.setOAuthConsumerSecret(consumerSecret);
	        builder.setOAuth2TokenType(token.getTokenType());
	        builder.setOAuth2AccessToken(token.getAccessToken());
	
	        Twitter twitter = new TwitterFactory(builder.build()).getInstance();
	        List<Status> followerStatus = twitter.getUserTimeline(2292372474l);
	        System.out.println(followerStatus.size());
		}catch(Exception e){
			System.out.println("Megh except, " + e);
		}

        
//		String[] bestTimes = TwitterFollowers.fetchBestTimeToPost(2292372474l, null);
//		for(int i = 0; i<bestTimes.length; i++){
//			System.out.println(bestTimes[i]);
//		}
	}
}
